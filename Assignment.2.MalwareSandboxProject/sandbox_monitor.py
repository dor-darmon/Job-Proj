import os
import time
import subprocess
import psutil
import threading
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

class FileMonitorHandler(FileSystemEventHandler):
    # Handles file system events using Watchdog library
    def __init__(self, log_callback):
        self.log_callback = log_callback

    def on_modified(self, event):
        if not event.is_directory:
            self.log_callback(f"[FILE MODIFIED] {event.src_path}")

    def on_created(self, event):
        if not event.is_directory:
            self.log_callback(f"[FILE CREATED] {event.src_path}")

    def on_deleted(self, event):
        if not event.is_directory:
            self.log_callback(f"[FILE DELETED] {event.src_path}")

    def on_moved(self, event):
        # Handles file renaming (common in ransomware attacks)
        if not event.is_directory:
            self.log_callback(f"[FILE RENAMED] {event.src_path} -> {event.dest_path}")

class SandboxEngine:
    # Main engine for executing and monitoring the malware
    def __init__(self, log_callback):
        self.log_callback = log_callback
        self.observer = None
        self.process = None

    def start_monitoring(self, directory):
        # Starts the file system observer
        self.observer = Observer()
        event_handler = FileMonitorHandler(self.log_callback)
        self.observer.schedule(event_handler, directory, recursive=False)
        self.observer.start()
        self.log_callback(f"Monitoring active on: {directory}")

    def execute_sample(self, file_path, timeout=30):
        # Determines the file type and executes it within a subprocess.
        try:
            self.log_callback(f"Executing sample: {file_path}")
            
            # Initialize the command list
            cmd = []
            
            # Determine execution logic based on file extension
            if file_path.endswith('.py'):
                # Execute Python script using the current interpreter
                cmd = ['python', file_path]
            elif file_path.endswith('.exe'):
                # Execute compiled Windows binary directly
                cmd = [file_path]
            elif file_path.endswith('.bat') or file_path.endswith('.cmd'):
                # Execute Windows batch script
                cmd = [file_path]
            else:
                self.log_callback("Error: Unsupported file type. Please select .py, .exe, or .bat.")
                return

            # Launch the subprocess with output redirection (PIPE)
            # text=True ensures output is returned as string, not bytes
            self.process = subprocess.Popen(
                cmd, 
                stdout=subprocess.PIPE, 
                stderr=subprocess.PIPE,
                text=True
            )
            
            # Start the monitoring lifecycle in a separate background thread
            # Daemon=True ensures the thread dies if the main app closes
            monitor_thread = threading.Thread(
                target=self._monitor_lifecycle, 
                args=(timeout,), 
                daemon=True
            )
            monitor_thread.start()

        except Exception as e:
            self.log_callback(f"Execution failed: {str(e)}")

    def _monitor_lifecycle(self, timeout):
        # Monitors process stats, network connections, and enforces timeout
        if not self.process:
            return

        start_time = time.time()
        pid = self.process.pid
        
        try:
            ps_proc = psutil.Process(pid)
            
            while self.process.poll() is None:
                # 1. Enforce Timeout (Edge Case: Infinite Loops)
                elapsed = time.time() - start_time
                if elapsed > timeout:
                    self.log_callback(f"[ALERT] Timeout reached ({timeout}s). Killing process.")
                    self.process.kill()
                    break

                # 2. Monitor Resources (CPU/RAM)
                try:
                    cpu = ps_proc.cpu_percent(interval=0.5)
                    mem = ps_proc.memory_info().rss / 1024 / 1024
                    
                    # 3. Monitor Network (Edge Case: C&C Communication)
                    connections = ps_proc.connections(kind='inet')
                    net_activity = ""
                    if connections:
                        for conn in connections:
                            if conn.status == 'ESTABLISHED' or conn.status == 'SYN_SENT':
                                raddr = conn.raddr if conn.raddr else "Unknown"
                                net_activity = f" | [NET] Connecting to: {raddr}"

                    self.log_callback(f"[STATS] CPU: {cpu}% | RAM: {mem:.2f}MB{net_activity}")
                    
                except (psutil.NoSuchProcess, psutil.AccessDenied):
                    break
            
            # Capture standard output and errors from the malware
            stdout, stderr = self.process.communicate()
            if stdout:
                self.log_callback(f"[MALWARE OUTPUT] {stdout.strip()}")
            if stderr:
                self.log_callback(f"[MALWARE ERROR] {stderr.strip()}")

            self.log_callback(f"Process finished. Return Code: {self.process.returncode}")

        except Exception as e:
            self.log_callback(f"Monitor error: {e}")
        finally:
            self.stop_monitoring()

    def stop_monitoring(self):
        # Stops the file observer
        if self.observer:
            if self.observer.is_alive():
                self.observer.stop()
                self.observer.join()
            self.log_callback("File monitoring stopped.")